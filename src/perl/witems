#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use Config::General;
use File::Basename;
use File::Copy;
use File::Temp qw/ tempdir /;
use FindBin;
use Getopt::Long;
use IO::Scalar;
use Template;

sub BEGIN {
    if (exists $ENV{WORKER_DIR} && defined $ENV{WORKER_DIR} &&
            length($ENV{WORKER_DIR}) > 0) {
        unshift(@INC, "$ENV{WORKER_DIR}/lib/perl");
    } else {
        unshift(@INC, "$FindBin::Bin/../lib/perl");
    }
}

use Worker::CsvProvider;
use Worker::DataProvider;
use Worker::Preprocessor;
use Worker::Utils qw(
    find_worker_dir check_file msg parse_hdr create_run_script
    create_run_cmd get_cmd_line_resources create_run_cmd dump2file
    find_worker_dir
);
use Pbs::Parser;

# directory containing the Worker software
my $worker_dir = find_worker_dir();

my $config_file = "${worker_dir}/conf/worker.conf";
check_file($config_file, 'configuration file', 1);
msg("reading config file '$config_file'...");
my $config = Config::General->new($config_file);
my %conf = $config->getall();
msg("config file read");
msg(Dumper(\%conf) . "\n");

# files to be created in the working directory, or extensions thereof
my $pbs_file     = $conf{pbs_file};       # PBS script name
my $pbs_shebang  = $conf{pbs_shebang};    # shebang for generated PBS file
my $arrayid_ext  = $conf{arrayid_ext};    # extension for arrayid files
my $batch_ext    = $conf{batch_ext};      # extension for generated batch
                                          # file
my $prepr_ext    = $conf{prepr_ext};      # extension for preprocessed batch
my $default_sh   = $conf{default_sh};     # templ. batch name
my $default_pbs  = $conf{default_pbs};    # templ. PBS name

# files to be found in the $worker_dir
# PBS template
my $pbs_tmpl = "$worker_dir$conf{pbs_tmpl_dir}/$pbs_file$conf{pbs_tmpl_ext}";
my $worker_hdr = "${worker_dir}$conf{worker_hdr}";  # worker header file

# some defaults
my $email = $conf{email};     # email to send complaints to

# test whether necessary files can be found and read
check_file($pbs_tmpl, "PBS file template", 1, 0, $email);
check_file($worker_hdr, "worker header file", 1, 0, $email);

# configure command line parsing
Getopt::Long::Configure("no_ignore_case", "pass_through",
			"no_auto_abbrev");

# command line variables and deal with them
my $batch_tmpl = undef;
my @data_files = ();
my $pbs_array_str = undef;
my $verbose = 0;
my $quiet = 0;
my $allow_loose_quotes = undef;
my $escape_char = undef;

GetOptions(
        "batch=s"              => \$batch_tmpl,
        "data=s"               => \@data_files,
        "verbose"              => \$verbose,
        "quiet"                => \$quiet,
        "allow_loose_quotes"   => \$allow_loose_quotes,
        "escape_char=s"        => \$escape_char,
        "help"                 => \&show_help,
        "t=s"                  => \$pbs_array_str,
);
# if there are additional qsub options, they are in @ARGV and will
# be passed to qsub

# set verbosity for Worker::Utils
$Worker::Utils::verbose = $verbose;

msg("validating options...");
# check for mandatory options
unless (defined $batch_tmpl) {
    print STDERR "### error: batch file template should be specified\n";
    print_help();
    exit 1;
}
unless (scalar(@data_files) > 0 || defined $pbs_array_str) {
    print STDERR "### error: either a data file or an array request \n";
    print STDERR "           should be specified\n";
    print_help();
    exit 1;
}
# check that files, if supplied, can be read
msg("checking file existances...");
check_file($batch_tmpl, "batch template file");
if (scalar(@data_files) > 0) {
    @data_files = split(/,/, join(',', @data_files));
    check_file($_, "data file") foreach @data_files;
}
msg("files exist");

# extract file name from $batch_tmpl
my ($batch_tmpl_file, $batch_path) = fileparse($batch_tmpl);

# files to be created in the working directory
my $batch_file = "${batch_tmpl_file}${batch_ext}";
msg("batch file: '$batch_file'");

# separator for work items in the work items file
my $separator = parse_hdr($worker_hdr);

# initialize Template engine
msg("initializing template engine...");
my $tt_config = {ABSOLUTE => 1};
my $engine = Template->new($tt_config);
msg("template engine initialized");

# parse batch file template
msg("parsing batch template file...");
my $pbs_parser = Pbs::Parser->new();
my $pbs = $pbs_parser->parse_file($batch_tmpl);
unless ($pbs->has_script()) {
    print STDERR "### warning: batch template file '$batch_tmpl'\n";
    print STDERR "             seems to contain no actual work\n";
}
msg("batch template file parsed");

my $arrayid_file_name = "${batch_tmpl}${arrayid_ext}";
# create data providers
msg("creating providers...");
my $provider = Worker::DataProvider->create(
    {
        'pbs_parser'         => $pbs_parser,
        'pbs_array_str'      => $pbs_array_str,
        'arrayid_file_name'  => $arrayid_file_name,
        'allow_loose_quotes' => $allow_loose_quotes,
        'escape_char'        => $escape_char
    },
    @data_files
);
msg("all providers created");

# get all variable names and preprocss batch file template string
my @variables = $provider->get_vars();
msg("preprocessing script for " . join(', ', map {"'$_'"} @variables) .
    '...');
my $batch_str = preprocess($pbs->get_script(), @variables);
msg("script preprocessed");
dump2file($batch_str, "${batch_tmpl}${prepr_ext}") if $verbose;

my $job_size = 0;

# create the batch file
msg("creating batch file...");
my $fh = undef;
unless (open($fh, ">$batch_file")) {
    print STDERR "### error: can't open file '$batch_file'\n";
    print STDERR "           for writing: $!\n";
    exit 2;
}
while ($provider->has_next()) {
    $job_size++;
    msg("work item $job_size...");
    my $vars = $provider->get_next();
    unless ($engine->process(\$batch_str, $vars, $fh)) {
        print STDERR "### error: problem with template,\n";
        print STDERR "           ", $engine->error(), "\n";
        exit 4;
    }
    print $fh "\n$separator\n";
}
close($fh);
$provider->destroy();
msg("batch file created");

print "total number of work items: $job_size\n" unless $quiet;

# arrayid_file is no longer needed, so it can be removed
msg("deleting arrayid file...");
unlink($arrayid_file_name) if defined $pbs_array_str;
    
# check whether PBS script had an explicit shebang, if not, use
# default, and issue a warning
if ($pbs->has_shebang()) {
    $pbs_shebang = $pbs->get_shebang();
} else {
    print STDERR "### warning: PBS script contains no shebang line,\n";
    print STDERR "#            please refer to qsub's man page\n";
}

# succesfully completed witems
exit 0;

# ----------------------------------------------------------------------
# preprocess the batch template file string to convert $var to [%var%]
# if they occur in the parameter list
# ----------------------------------------------------------------------
sub preprocess {
    my $batch_in = shift(@_);
    my $sh1 = IO::Scalar->new(\$batch_in);
    my $str = '';
    my $sh2 = IO::Scalar->new(\$str);
    my $preprocessor = Worker::Preprocessor->new(@_);
    $preprocessor->preprocess_file($sh1, $sh2);
    $sh1->close();
    $sh2->close();
    return $str;
}

# ----------------------------------------------------------------------
# print the script's help stuff
# ----------------------------------------------------------------------
sub print_help {
    print STDERR <<EOI
### usage: witems  -batch <batch-file>          \\
#                  [-data <data-files>]         \\
#                  [-t <array-req>]             \\
#                  [-verbose] [-help]
#
# Generate a worker items file
# 
#   -batch <batch-file>   : Bash file template, containing variables to be
#                           replaced with data from the data file(s) or the
#                           array request option
#   -data <data-files>    : comma-separated list of data files (default CSV
#                           files) used to provide the data for the work
#                           items
#   -t <array-req>        : array request options, e.g., 1-10
#   -verbose              : feedback information is written to standard
#                           error
#   -quiet                : do not generate info messages
#   -allow_loose_quotes   : enable CSV loose quote parsing mode, do not
#                           use this unless you really know what you are
#                           doing
#   -escape_char <c>      : use <c> as escape character for the CSV parser,
#                           do not use this unless you really know what
#                           you are doing
#   -help                 : print this help message
EOI
}

# ------------------------------------------------------------
# shows help and exits
# ----------------------------------------------------------------------
sub show_help {
    print_help();
    exit 0;
}
